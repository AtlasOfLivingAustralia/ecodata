import groovy.transform.Field
import org.elasticsearch.action.search.SearchResponse
import org.elasticsearch.search.aggregations.Aggregation
import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation
import org.elasticsearch.search.aggregations.bucket.histogram.ParsedHistogram
import org.elasticsearch.search.aggregations.bucket.range.ParsedRange

@Field SearchResponse searchResponse

json {

    hits {
        total searchResponse.hits?.totalHits.value
        hits tmpl.searchHit(searchResponse.hits?.hits as List)
    }

    facets searchResponse.aggregations?.collectEntries { Aggregation agg ->
        String type = agg.type
        def result = null
        long total = 0
        switch (agg.type) {
            case 'sterms':
            case 'lterms':
            case 'terms':
                type = 'terms'
                MultiBucketsAggregation multiBucketsAggregation = (MultiBucketsAggregation)agg
                result = [(agg.name): [terms:multiBucketsAggregation.buckets.collect { bucket ->
                    total += bucket.docCount
                    [term: bucket.keyAsString, count: bucket.docCount] // keyAsString converts boolean 0/1 to false/true
                }, _type:type, total:total]]
                break
            case 'range':
                ParsedRange range = (ParsedRange)agg
                result = [(agg.name): [ranges:range.buckets.collect { bucket ->
                    total += bucket.docCount
                    Map bucketAsMap = [term: bucket.key, count: bucket.docCount]
                    def from = bucket.from
                    if (from && from != Double.NEGATIVE_INFINITY && from != Double.POSITIVE_INFINITY) {
                        bucketAsMap += [from:from, from_str:bucket.fromAsString]
                    }
                    def to = bucket.to
                    if (to && to != Double.NEGATIVE_INFINITY && to != Double.POSITIVE_INFINITY) {
                        bucketAsMap += [to:to, to_str:bucket.toAsString]
                    }
                    bucketAsMap
                }, _type:type, total:total]]
                break
            case 'histogram':
                ParsedHistogram histogram = (ParsedHistogram)agg
                result = [(agg.name): [entries:histogram.buckets.collect { bucket ->
                    total += bucket.docCount
                    [key: bucket.key, count: bucket.docCount]
                }, _type:type, total:total]]
                break
            case 'stats':

            default:
                break
        }
        result
    }

}