package au.org.ala.ecodata.converter

import au.org.ala.ecodata.Activity
import au.org.ala.ecodata.Output
import au.org.ala.ecodata.Project
import au.org.ala.ecodata.ProjectActivity
import au.org.ala.ecodata.Site
import groovy.util.logging.Log4j
import org.apache.commons.lang.StringUtils

/**
 * Utility for converting the data submitted for an Output into one or more Records with the correct Darwin Core fields
 * so that it can be exported to the Biocache.
 * <p/>
 * In order for an Output to be converted successfully into one or more Records, the following rules MUST be met:
 * <ol>
 *     <li>The Output metadata (i.e. the dataModel.json file) must have '"record": true' at the top level
 *     <li>Each dataModel item must have a dataType defined (this includes columns within a list model)
 *     <li>Each dataModel that needs to be mapped to a Darwin Core field must have '"dwcAttribute": "[attribute name]"' defined
 * </ol>
 *
 * The following is a simple example of how an Output metadata model should look in order for Record creation to work:
 *<pre>
 * {
 *   "modelName": "Sample",
 *   "record": "true",
 *   "dataModel": [
 *     {
 *       "dataType": "text",
 *       "name": "fieldName1",
 *       "dwcAttribute": "darwinCoreTerm1",
 *     },
 *     {
 *       "dataType": "list",
 *       "name": "mylist",
 *       "columns": [
 *         {
 *           "name": "col1",
 *           "dataType": "text",
 *           "dwcAttribute": "darwinCoreTerm2"
 *         },
 *         ...
 *       }
 *   ]
 *   ...
 * }
 * </pre>
 */
@Log4j
class RecordConverter {

    static final List MULTI_ITEM_DATA_TYPES = ["list", "masterDetail"]
    static final String DELIMITER = ";"
    static final String DEFAULT_BASIS_OF_RECORD = "HumanObservation"

    static List<Map> convertRecords(Project project, Site site, ProjectActivity projectActivity, Activity activity, Output output, Map data, Map outputMetadata) {
        // Outputs are made up of multiple 'dataModels', where each dataModel could map to one or more Record fields
        // and/or one or more Records. For example, a dataModel with a type of 'list' will map to one Record per item in
        // the list. Further, each item in the list is a 'dataModel' on it's own, which will map to one or more fields.

        // First create the skeleton of the Record. This contains the various object identifiers for related data
        Map baseRecord = [
                outputId: output.outputId,
                projectId: activity.projectId,
                projectActivityId: activity.projectActivityId,
                activityId: activity.activityId,
                userId: activity.userId
        ]

        // Populate the skeleton with Record attributes which are derived from the Activity. These attributes are shared
        // by all Records that are generated from this Output.
        addOrAppendFields(baseRecord, extractHeaderDetails(project, site, projectActivity, activity))

        // Split the dataModels in the output into those which produce Record FIELDS, and those which produce multiple
        // Records. When there is a mix of both, the fields generated by the 'singleItemModels' will be shared by all
        // Records that are generated from this Output.
        List singleItemModels
        List multiItemModels
        (singleItemModels, multiItemModels) = outputMetadata?.dataModel?.split {
            !MULTI_ITEM_DATA_TYPES.contains(it.dataType.toLowerCase())
        }

        // For each singleItemModel, get the appropriate field converter for the data type, generate the individual
        // Record fields and add them to the skeleton Record
        singleItemModels?.each { Map dataModel ->
            RecordFieldConverter converter = getFieldConverter(dataModel.dataType)
            List<Map> recordFieldSets = converter.convert(data, dataModel)
            addOrAppendFields(baseRecord, recordFieldSets[0])
        }

        List<Map> records = []
        if (multiItemModels) {

            // For each multiItemModel, get the appropriate field converter for the data type and generate the list of field
            // sets which will be converted into Records. For each field set, add a copy of the skeleton Record so it has
            // all the common fields
            multiItemModels?.each { Map dataModel ->
                RecordFieldConverter converter = getFieldConverter(dataModel.dataType)
                List<Map> recordFieldSets = converter.convert(data, dataModel)

                recordFieldSets.each {
                    addOrAppendFields(it, baseRecord)
                }

                records.addAll(recordFieldSets)
            }
        } else {
            // If there are no multiItemModels, then the 'skeleton' record has all that we need, so return it.
            records << baseRecord
        }

        // We are now left with a list of one or more Maps, where each Map contains all the fields for an individual Record.
        records
    }

    private static addOrAppendFields(Map target, Map source) {
        source?.each { key, value ->
            if (target.containsKey(key) && target[key] && target[key] != value) {
                target[key] = "${target[key]}${DELIMITER}${value}"
            } else {
                target[key] = value
            }
        }
    }

    protected static RecordFieldConverter getFieldConverter(String outputDataType) {
        String packageName = RecordFieldConverter.class.package.getName()
        String className = "${StringUtils.capitalize(outputDataType).replaceAll("[ _\\-]", "")}Converter"

        RecordFieldConverter converter
        try {
            converter = Class.forName("${packageName}.${className}")?.newInstance()
        } catch (ClassNotFoundException e) {
            log.warn "No specific converter found for output data type ${outputDataType} with class name ${packageName}.${className}, using generic converter"
            converter = new GenericFieldConverter()
        }

        converter
    }

    private static Map extractHeaderDetails(Project project, Site site, ProjectActivity projectActivity, Activity activity) {
        Map dwcFields = [:]

        // Project fields
        if (project) {
            dwcFields.rights = project.dataSharingLicense
            dwcFields.rightsHolder = project.organisationName
            dwcFields.insitutionID = project.organisationName
            dwcFields.accessRights = project.projectPrivacy
            dwcFields.basisOfRecord = DEFAULT_BASIS_OF_RECORD
        }

        // ProjectActivity fields
        if (projectActivity) {
            dwcFields.datasetID = projectActivity.projectActivityId
            dwcFields.datasetName = projectActivity.name
        }

        // Site fields
        if (site) {
            dwcFields.locationID = site.siteId
            dwcFields.locationName = site.name
            dwcFields.locationRemarks = "${site.description}${site.description && site.notes ? ';' : ''}${site.notes}"
        }

        // Activity fields
        if (activity) {
            dwcFields.userId = activity.userId
            dwcFields.recordedBy = activity.userId
            dwcFields.eventID = activity.activityId
            dwcFields.eventDate = activity.dateCreated
            dwcFields.verbatimEventDate = activity.startDate
        }

        dwcFields
    }
}
